# java

## 概述

### java语言特点

- 简单性
- 多线程
- 面向对象
- 可移植

	- jvm

		- 屏蔽了操作系统之间的差异

- 健壮性

	- GC垃圾自动回收机制

### java加载与运行

## 基础语法

### 标识符

- 程序员有权利命名的单词
- 分类

	- 类名、接口名、变量名、方法名、常量名

### 关键字

- 全部小写

### 变量（Var）

- 根据数据类型分配内存
- 变量赋值后才能访问，赋值才开辟内存
- 变量的作用域

	- 出了大括号就不认识

### 就近原则

## 数据类型

### 基本数据类型

- 整型

	- byte（1）、short（2）、int（4）、long（8）

- 浮点型

	- float（4）、double（8）

		- 任意一个浮点型都比整数型空间大

- 布尔型

	- Boolean（1）

- 字符型

	- char（2）

- 自动类型转换

	- 小容量可以自动转换成大容量

- 强制类型转换

	- 大容量不能直接赋值给小容量
	- 可能损失精度

### 引用数据类型

- 字符串型

	- string

		- 默认值null (未赋值)

- BigDecimal
- 除了基本数据类型

### 进制转换

- 原码、反码、补码

## 运算符

### 算术运算符

- +   -  *  /    *   ++    --

	-  i++  后++

### 关系运算符

- 运算结果都是布尔类型

### 逻辑运算符

- &    |      ！
- &&短路与      ||短路或

	- &与&&区别

		- 运算结果没有区别
		- &&会发生短路现象
		- 短路与现象

			- 当左边的表达式为false时，右边表达式不执行的时候的现象

		- 短路或现象

			- 当左边结果是true时，右边不执行

- 运算结果是布尔类型

### 赋值运算符

- 基本

	- =

		- 右边优先级高

- 扩展

	- +=   -=    *=    /=     %=

		- 使用扩展赋值运算时，永远不会改变数据类型

### 位运算符

### 条件运算符

- 布尔表达式 ？ 表达式1   ： 表达式2

### 字符串连接运算符

- +

### 其他运算符

## 键盘输入

### 创建一个键盘扫描器对象

### import java.utill.scanner

## 控制语句

### 选择语句（分支语句）

- if

	- 写法

		- if () {}
		- if () {} else {}
		- if () {} else  if {}...

	- 若分支只有一条，可省略大括号

- switch

	- 支持int、String类型
	- 可合并

		- case：1 case ：2   case：3  

### 循环语句

- for
- while
- do...while

### 转向语句

- break

	- 一个单词就是一个语句
	- 终止离他最近的循环语句

- continue

	- 结束当前循环，重新开始下一次循环

- return

## 方法

### 基础

- （C++函数）
- 语法

	- 定义

		- [修饰符列表]  返回值类型   方法名   （形参列表）{}

- 返回值

	- 非void必须有return

- 调用

	- 类名 . 方法名 ( )
	- 类名可省情况

		- 在同一个类中

### 参数传递规则

- 参数传递时，一定是将“盒子”中的东西复制一份传递过去（包括地址）

	- int  x = 1；
int  y = x；

		- 把x保存的 1 复制一份给y

	- Person  p1 = Ox1234
Person  p2 = p1

		- p1保存的Ox1234复制给p2
		- 桌面快捷方式

### jvm内存结构

- 方法区（静态区）

	- 存放代码片段（ . class文件）
	- 类先加载

- 栈内存

	- 在方法调用的时候，该方法需要的内存空间在栈中分配
	- 调用时压栈
	- 调用结束时弹栈
	- 方法不调用则不会在栈中分配空间
	- 栈中存储需要的内存，以及存储方法的局部变量

- 堆区、堆内存

### 方法重载机制（overload）

- 在同一个类中，功能1与功能2的功能相似
- 条件

	- 在同一个类中
	- 方法名相同
	- 参数列表不同

		- 个数
		- 类型
		- 顺序

	- 与返回值类型和修饰符无关

- 优点

	- 代码整齐
	- 易于代码编写

### 代码的包装

### 方法递归

- 若没有结束条件或递归过深，栈内存溢出
- 解决栈内存溢出问题思路

	- 一、检查结束条件
	- 二、手动调整jvm栈内存大小

		- java -x

	- 三、继续调大

- 递归内存图分析（栈）

## 面向对象

### 简介

- 面向对象与面向过程区别

	- 语言方面

		- c语言：全面向过程
		- c++：半过程半对象
		- java：全面向对象

	- 面向过程

		- 注重实现功能的步骤

			- 以“我”为中心

		- 注重实现功能的因果关系（因A则B、因B则C）
		- 没有对象的概念
		- 例

			- “集成显卡”

				- 显卡焊死在主板

		- 缺点

			- 每一步与每一步的因果关系联合起来，形成子模块，任何一个因果关系出现问题，系统都会出现问题
			- 代码之间耦合度太高，扩展力太差

				- 螺母、焊接

		- 优点

			- 对小型项目，开发效率较高

				- 直接编写代码

	- 面向对象

		- 符合人类的思维方式

			- 主流原因

		- 将现实世界分割成不同单位，每一个单元都实现成对象，然后驱动，让各个对象协作起来形成一个系统
		- 例

			- “独显”

				- 可扩展

		- 优点

			- 耦合度低、扩展力强

- 面向对象三大特征

	- 封装
	- 继承
	- 多态

- 三个术语

	- OOA

		- 面向对象分析

	- OOD

		- 面向对象设计

	- OOP

		- 面向对象编程

### 类和对象

- 概念

	- 类

		- 是抽象的结果 ，是一个描述共同特征的摸板
		- 共同特征

			- 属性

				- 性别、名字等

			- 方法

				- 个人特长等

		- 所有类都是 引用数据类型

	- 对象（实例）

		- 是实际存在的个体

- 关系

	- 有共同特征的对象可以抽象为同一类
	- 定义“类”后，再通过“类”这个模板来创建“对象”

- 两个过程

	- 实例化

		- 通过“类”创建”对象“的过程

	- 抽象

		- 通过“对象”抽取共同特征归为“类”的过程

### 类的定义

- 语法

	- [修饰符列表]  class   类名  {
类体=属性+方法
}

- 属性

	- 以“变量”形式存在

		- 成员变量（方法体外）

- 方法

	- 描述动作/行为

### 创建对象

- 语法

	- new  类名 ( )

### 实例变量

- 对象级别的变量
- 不能通过类名直接访问实例变量（未new对象前）
- 引用

	- 访问： 引用 . 实例变量
	- 不一定是局部变量

## 对象的创建与使用

### 创建

- 类名   变量名 = new  类名（）
- 创建对象对应的jvm内存结构

	- 子主题 2

- 空指针异常 NullPointerException

	- 堆内存地址丢失，实例变量无法被访问
	- 前提条件：“空引用”访问实例/对象相关的数据时
	- GC机制主要针对堆内存。
当一个java对象没有任
何引用指向该对象时，
GC会考虑回收释放该垃圾

## 构造方法

### 作用

- 创建对象

	- 并在创建对象过程中给属性赋值（初始化）

- 实例对象的初始化

### 缺省构造器

- 当一个类没有定义任何构造方法，系统会自动给类提供一个无参数的构造方法，叫做缺省构造器
- 手动提供构造方法后，系统不再提供无参数构造方法

	- 建议将无参数构造方法手动写出来

### 支持方法重载

### 创建

- 语法

	- [修饰符列表]  构造方法名 ( 形参) { }

		- 方法名与类名一致

	- 对比普通方法

		- [修饰符列表]  返回值类型  方法名（形参）{ }

### 调用

- new运算符
- new  构造方法名 ( 实参 )

## 面向对象三大特征之

### 封装

- 定义

	- 包装

- 作用

	- 保证内部结构安全
	- 屏蔽复杂，暴露简单

- 优点
- 步骤

	- 属性私有化

		- private关键字

	- 每个属性对外提供set和get方法

		- 可设置关卡

- 实例方法

	- 没有static的方法
	- 必须先new一个对象才能调用

		- 对象级别的行为

- set与get

	- 固定格式

		- public int getAge(){
        return age；
}
    public void setAge(int nianling){
        age = nianling;
    }

## static

### 简介

- static修饰的都是类相关的，都采用“类名 .  ”方式调用
- 变量的分类

	- 方法体内

		- 局部变量

			- 存储在栈内存

	- 方法体外

		- 成员变量

			- 实例变量

				- int   i
				- 存储在堆内存

			- 静态变量

				- static   int   i
				- 存储在方法区

- 方法分类

	- 实例方法

		- 没有static
		- 需要先new对象，后调用
		- 可能出现空指针异常

	- 静态方法

		- 通过类访问
		- 不需要对象的参与

### 什么时候用static ？

- 属性

	- 使用

		- 类对象的某个属性都一样

			- 中国人的国籍都是中国

	- 不使用

		- name

			- 不同对象的name不同

- 方法

	- 使用

		- 工具类中的方法

			- 使用类名调用，方便

		- 类行为

	- 不使用

		- 对象行为

### 访问

- 静态属性（方法）

	- 类名 . 属性名

- 实例属性（方法）

	- 引用 . 属性名

### 静态代码块

- 定义

	- static   {
语句；
}

- 特点

	- 类加载时执行，且只执行一次
	- 自上而下执行

- 存储

	- 方法区

- 作用

	- 不常用
	- 记录日志的代码

### 实例代码块

- 定义

	- {
语句；
}

- 作用

	- 特殊的时机，在构造方法之前执行

## this

### 简介

- 关键字，小写
- 内存

	- 堆内存，保存对象地址

### 定义

- 一个对象一个this
- 是一个变量，是一个引用，保存当前对象的内存地址

### 应用

- 只能使用在实例方法中，谁调用this就是谁
- 大部分情况下可省略

### this（）用法

- 使用在构造方法中
- 通过当前的构造方法，调用另一个本类的构造方法

	- this（1970,1,1）
	- 实质：代码复用
	- 注意：两个构造方法在同一类中

## jvm内存结构

## 方法区

## 主要存储
代码片段

## 最先有数据
最先加载类

## 栈

## 主要存储
局部变量

## 方法执行时压栈，
该方法在栈中
分配内存。
使用最频繁

## new出来的
变量都是局部变量，
存储在栈中；
局部变量保存
实例对象的堆内存地址
即”引用“

## 创建对象对应的jvm内存结构

## 堆内存

## 存储new运算符
创建的对象(塑料袋)
以及
实例变量(塑料袋中)

## new作用即在堆内
存开辟一块空间

## new m22_user();

## =

## m22_user user1

*XMind: ZEN - Trial Version*