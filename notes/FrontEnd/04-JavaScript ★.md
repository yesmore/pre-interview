# JavaScript

## 基础

### 简介

- 起源

	- 1995年诞生

		- 前身：livescirpt

- JScript

	- 与JavaScript一样

- JavaScript组成

	- ECMAScript标准

		- 不同浏览器的JavaScript实现方式（引擎）不同

			- 如chrom：V8

	- DOM

		- 文档对象模型

	- BOM

		- 浏览器

- JavaScript特点

	- 解释型语言

		- 编译：全文翻译
		- 解释：逐句翻译

	- 类似于C和Java的语法结构
	- 动态语言
	- 基于原型的面向对象

- 代码位置

	- <head>的<script>标签中
	-  外部 .js 文件中

		- 通过scipt标签引入

			- 使用后，内部的script标签不能再编写代码，除非重新创建一个script标签

		- 优点

			- 在不同页面引用
			- 利用到浏览器的缓存机制

	- onclick属性中
	- 超链接的href属性中

- 垃圾回收机制GC

	- 当一个对象没有任何变量或属性对它引用，无法操作该对象
	- 自动回收机制

		- 不需要手动也不能进行垃圾回收机制

	- 触发机制

		- obj = null

### 语法

- 注释

	- /**/
	- //

- 严格区分大小写
- 语句分号以分号结尾

	- 如果不写分号，浏览器会自动添加，但是会消耗系统资源

		- 可能加错

- js会忽略多个空格和换行

	- 可以利用空格和换行对代码进行格式化

### 字面量和变量

- 字面量

	- 不可改变的值

		- 如1/2/3...

	- 一般不会直接使用

- 变量

	- 用来保存字面量，可变
	- 声明

		- var  变量名；

	- 赋值

		- 变量名 = 值；

### 标识符

- 在计算中所有可以自主命名的都可称为标识符

	- 如变量名、函数名、属性名。。

- 命名规则

	- 可含有字母、数字、_、$
	- 不能以数字开头
	- 不能是ES中的关键字或保留字
	- 标识符一般采用驼峰命名法

- js底层保存标识符时，采用utf-8，理论上讲，utf-8的内容都可作为标识符

### 数据类型

- 分类

	- 基本数据类型

		- String  字符串

			- str = “hello”； 
			- 转义字符：\"

		- Number  数值

			- 所有的数值都是number类型
			- Number.MAX_VALUE

				- 数值中的最大值
				- 超过则返回 “Infinity”

			- NaN

				- 不是一个数字

			- 使用浮点数运算可能得到不精确的结果

		- Boolean  布尔值

			- true、false

		- Null  空值

			- 是一个对象object

		- Undefined  未定义

			- 没有赋值的变量

	- 引用数据类型

		- Object  对象

- 强制类型转换

	- 转String

		- 调用被转换数据的 toString() 方法，有返回值

			- null/undefine没有此方法

		- 调用 string() 函数

	- 转Number

		- Number（）函数
		- 字符串转num

			- parseInt（str，[进制]）

				- 将字符串中有效整数取出来转换成num

			- parseFloat（str，[进制]）

	- 转Boolean

		- Boolean（）函数

			- 除了0、NaN、空串、Null、undefined，其余都是true（包括object）

- 其他类型数字

	- 0x10 十六进制
	- 045  八进制

- typeof  变量

	- 检查变量的类型

### 运算符（操作符）

- 算术运算符

	- +  、 -  、* 、/ 、&
	- 非数值运算：先转换成数值再运算

		- ”+“ 除外

	- 如何值与NaN做运算都得NaN

- 一元运算符

	- +  正号
	- -  负号
	- ++、--

- 逻辑运算符

	- ！非
	- &&  与

		- “爱情”

	- ||  或

		- “亲情”

- 赋值运算符

	- = 、+=、-=、*=、/=、%=

- 关系运算符

	- >   <   >=   <=  ==  !=
	- ===  !==

		- 判断两个值是否全等/不等

			- 不会做自动类型转换

	- 若只有一个是字符串，则将字符串转换成数值再比较
	- 若符号两侧都是字符串，则比较的是utf8编码

		- 一位一位比
		- 打印Unicode编码

			- 在js中：console.log('\u2620');
			- 在html中：<h1>&#9760;</h1>

				- 必须转换为10进制

	- NaN不与任何值相等，包括其本身

		- 通过isNaN() 函数判断是否为NaN

- 条件运算符

	- 又‘三元运算符’
	- 语法

		- 条件表达式  ？语句1  ：语句2

- 逗号运算符

	- 分割语句

- 优先级

### 流程控制

- 代码块

	- 同一个大括号内的语句

		- 要么都执行要么都不执行

	- 只具有分组的作用

- prompt()弹出文本框

	- 返回值是string类型

		- “+”转换成数值类型

- 分类

	- 条件判断语句

		- if

			- 同C++、java

		- if.....else
		- if....else  if....else

	- 条件分支语句

		- switch...case

			- 全等判断

	- 循环语句

		- while
		- do....while
		- for

	- break、continue
	- label：循环语句

		- break label

### 面向对象

- 简介

	- 复合的数据类型，可保存多个不同数据类型的属性
	- 基本数据类型与引用数据类型区别

		- 基本数据类型

			- 值直接在栈内存中存储
			- 值与值独立存在
			- 值与值的比较看“值”

		- 引用数据类型

			- 值放在堆内存中
			- 变量保存的是对象的 内存地址
			- 值与值的比较看“内存地址”

- 对象的分类

	- 内建对象

		- 由ES标准中定义的对象，在任何的ES的实现中都可以使用
		- Math、String、Number...

	- 宿主对象

		- 由JS的运行环境提供的对象，主要指浏览器提供的对象
		- BOM、DOM

			- console.log、document.write...

	- 自定义对象

		- 开发人员自己创建的对象

- 操作

	- 创建对象

		- 构造函数constructor

			- 使用new关键字调用的函数

				- new  Object();

		- 对象字面量(py字典)

			- 语法

				- var  obj = {};

			- 可直接指定属性

				- {属性名：属性值，属性名：属性值... }
				- 特殊的属性名必须加引号

		- 工厂方法创建对象

			- 条件：大量重复的代码
			- 缺点：使用的构造函数都是Object，所创建的对象都是Object这是类型，无法区分出不同类型的对象

				- 对应解决方法

					- 构造函数

			- 语法

				- function  fun ( name, age,... ) {
    var obj = new  Object();
    obj.name = name;
    obj.age = 1age;
    ...
    return   obj;
}

var  obj1 = fun(’猪八戒‘，18);

	- 添加属性
	
		- 对象 . 属性名 = 属性值；
	
	- 读取属性
	
		- 对象 . 属性名
		- 如果对象没有该属性，返回undefined
	
	- 修改属性值
	
		- 对象 . 属性名 = 新值；
	
	- 删除对象属性
	
		- delete  对象 . 属性名

- 属性

	- 属性名

		- 不强制要求遵守标识符规范

			- 尽量按照标识符规范

		- 特殊属性名

			- 语法

				- 对象 [ "属性名" ] = 属性值
				- 可将属性名作为变量保存

	- 属性值

		- 可以是任意的数据类型（包括对象）

	- in 运算符

		- 检查对象中是否含有指定属性
		- 语法： “属性名”  in   对象

	- 遍历属性

		- for （var  变量  in  对象）{ }

			- obj[i]

- 方法

	- 函数作为对象的属性保存
	- 调用对象的函数称为调用方法
	- 方法重写

		- toString

			- 当我们直接在页面中打印一个对象时，其实是输出对象的toString方法返回值
			- 自定义toString

### 函数

- 简介

	- 函数也是对象
	- 封装功能

- 操作

	- 创建函数

		- 方法一：构造函数

			- fuc = new Function("document.write('hello');");
			- 创建一个构造函数（类定义）

				- function Person() {}

					- 首字母一般大写

			- 调用构造函数（实例化）

				- var per1 = new Person();
				- 调用普通函数var per1 = Person();

			- 执行流程

				- 1、立刻创建一个新的对象
2、将新建的对象设置为函数中的 this
3、逐行执行函数中的代码
4、将新建的对象作为返回值返回

			- instanceof

				- 检查一个对象是否是一个类的实例
				- 语法：对象  instanceof  构造函数

			- 优化

				- 将类中方法提取出来，定义在外部，避免每次new时都会创建该方法
				- 缺点：会污染全局作用域的命名空间，而且定义在全局作用域很不安全

			- 原型对象

				- 定义

					- 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，该属性对应着的对象，即原型对象

				- 特点

					- 函数作为普通函数调用prototype没有任何作用
					- 当函数通过构造函数调用时，所创建的对象中都会有一个隐含属性指向该构造函数的原型对象

						- 通过_ _proto_ _来访问该隐含属性

				- 作用

					- 原型对象相当于一个公共区域，所有同一个类的实例都可以访问
					- 可将对象中共有的内容，统一设置到原型对象中

						- 子主题 1

					- 相当于对不同类的相同属性或方法再次统一提取

				- 原型对象也有原型对象

					- mc.__proto__.__proto__

			- 检查 

				- in

					- 使用in检查对象是否含有某个属性，对象没有但是原型有

						- true

				- hasOwnProperty()

					- 检查自身中是否含有某属性

						- false

					- 该方法位于原型的原型对象
					- mc.hasOwnProperty('name')

		- 方法二：函数声明

			- function fun1() { }

		- 方法三：函数表达式

			- var  函数名=function（[形参]）{  }；
			- （匿名函数）

		- 方法三：立即执行函数

			- ( function( ){ alert('我是匿名函数~~') ; }  ) （）；
			- 用括号包围函数块，在后面加（）调用
			- 只会执行一次

	- 调用函数

		- 函数对象 ( )

- 函数参数

	- 形参

		- 相当于在函数中声明变量

			- var  a；

	- 实参

		- 解析器不会检查实参类型
		- 解析器不会检查实参数量，多余的不会被赋值
		- 可封装到对象中
		- 也可以是函数

- 返回值

	- return；

		- 默认为return  undefined；

	- 返回值类型

		- 任意（包括对象、函数）

- 作用域

	- 全局作用域

		- 特点

			- 直接写在script标签内
			- 在页面打开时创建，关闭时销毁

		- 全局变量

			- 在页面任意部分都可以访问

		- 全局对象window

			- 由浏览器创建，可直接使用
			- 创建的变量都会作为window对象的属性保存（全局作用域中）
			- 创建的函数都会作为window对象的方法保存

		- 声明提前

			- 变量声明提前

				- 使用var关键字声明的变量，会在所有的代码执行前被声明
				- 如果声明变量不使用var，不会提前

					- ==  window.a=1；

			- 函数声明提前

				- 使用 函数声明 创建的函数，会在所有代码执行之前被创建
				- 使用 函数表达式 创建的函数，不会被声明提前

	- 函数作用域

		- 特点

			- 在调用时创建，执行完毕时销毁
			- 每调用一次就会创建一个新的函数作用域
			- 可访问全局变量
			- 就近原则
			- 加window访问全局
			- 也有声明提前

				- 在函数中，不使用var声明的变量都成为全局变量（相当于window . xxx = xxx）

- this

	- 定义：解析器在调用函数时每次都会向函数内部传递的隐含参数
	- 含义：this指向的是一个对象，该对象成为函数执行的上下文对象
	- 根据函数调用方式不同，this会指向不同的对象

		- 以函数形式调用

			- this永远都是window

		- 以方法形式调用

			- this就是调用方法的那个对象

		- 以构造函数调用

			- this就是新创建的对象

		- 使用call、apply调用时

			- this是指定的对象

- 函数对象的方法

	- call（）

		- 等于调用函数执行
		- 可以将一个对象指定为第一个参数

			- 此时该对象为执行时的this

		- 可以将实参在对象后依次传递

			- call（obj，1,  2）

	- apply（）

		- 等于调用函数执行
		- 可以将一个对象指定为第一个参数

			- 此时该对象为执行时的this

		- 需要将实参封装到数组中统一传递

			- apply（obj，【1,2】）；

	- arguments（）

		- 调用函数时，浏览器自动传递两个隐含参数

			- 1、函数的上下文对象this
			- 2、封装实参的对象arguments

		- 定义

			- 是一个类数组对象
			- 也能用索引、length
			- 在调用函数时，所传递的实参都保存在arguments

		- 属性

			- callee

				- 对应一个函数对象，即当前正在执行的函数对象

### 数组Array对象

- 简介

	- 属于内建对象
	- 对象
	- 存值

		- 性能好

	- 使用数字作为索引（index）操作元素
	- 索引index

		- 从0开始的整数

	- 数组中元素可以是任意数据类型

- 操作

	- 创建

		- 方法一

			- 使用构造函数创建

				- 创建时同时可指定元素
				- 只传一个整数时，表示数组长度

			- var arr = new Array();

		- 方法二

			- 使用字面量创建数组

				- 创建时同时指定元素

			- var  arr = [ ] ;

	- 添加元素

		- 数组 [索引] = 值

	- 读

		- arr[ 索引]
		- 读取不存在的索引，返回undefined

	- 获取长度

		- arr . length
		- 对于连续数组可获取

	- 修改长度

		- arr.length = 10
		- 如果修改的length大于原长度，则空出多余部分
		- 如果小于原理长度，多出元素被删除

	- 遍历

		- 方法一：常规
		- 方法二：foreach（function（value，index，obj））

			- 需要函数作为参数
			- value：当前正在遍历的元素
			- index：索引值
			- obj：遍历的对象
			- 回调函数

				- 由我们创建但是不由我们调用的函数

- 方法

	- push（）

		- 向数组末尾添加一个或多个元素
		- 返回新长度

	- pop（）

		- 删除最后一个元素
		- 返回被删除的元素

	- unshift（）

		- 向数组开头添加一个或多个元素
		- 返回长度

	- shift（）

		- 删除数组第一个元素
		- 返回被删除的元素

	- slice（start [，end ]）

		- 从某个数组返回已有的元素

			- 提取指定的元素

		- 类似切片

			- 左闭右开
			- 有负值

		- 不影响原数组

	- splice（start，num，newelement）

		- 删除/替换数组中的元素
		- 参数

			- start：开始删除的位置
			- num：删除的数量
			- 第三个及以后：传递新元素，自动插入开始位置索引之前

		- 会影响原数组
		- 返回删除的元素

	- concat（）

		- 连接两个或多个数组或元素

			- 返回新数组

		- 不会对原数组产生影响

	- join（）

		- 把数组转换为一个字符串
		- 可指定字符串作为参数，作为元素之间的链接符号
		- 不会影响原数组

	- reverse（）

		- 颠倒数组元素顺序
		- 会影响原数组

	- sort（）

		- 对数值元素进行排序（Unicode编码）

			- 对数字排序可能出错
			- 可在sort中添加回调函数指定排序规则

				- 根据回调函数返回值决定元素位置
				- 升序：a-b
				- 降序：b-a

		- 会影响原数组

### Date对象

- 直接使用构造函数创建一个date对象

	- 会封装为当前代码执行的时间

- 创建指定的时间

	- 月/日/年  时/分/秒
	- new  Date（“12/03/2013 10:10:36”）

- 方法

	- getDate

		- 获取当前对象日期是几号

	- getDay（）

		- 返回当前日期是周几

	- getMonth（）

		- 获取当前月份

	- getFullyear（）

		- 获取年份

	- getTime（）

		- 获取当前时间戳（1970.1.1 0:0:0）
		- Date.now（）

			- 当前时间戳

### Math对象

- 定义

	- 封装了数学运算的属性和方法
	- 不是构造函数

- 属性

	- E

		- 底数e

	- PI

		- yuanzlv

- 方法

	- abs（）

		- 返回一个数的绝对值

	- random（）

		- 返回0~1之间的随机数
		- 生成0-X的随机数

			- Math.round（Math.random（）* X）

		- 生成X·Y的随机数

			- Math.round（Math.random（）* （y-x）+x）

	- ceil（）

		- 向上取整

	- floor（）

		- 向下取整

	- round（）

		- 四舍五入

	- max（）、min（）

		- 获取多个数的最值

	- pow（x，y）

		- 返回x的y次幂

	- sqrt（）

		- 开方

### 包装类

- 作用

	- 将基本数据类型转换为对象
	- 实际开发中不会使用

- 三个包装类

	- String（）
	- Number（）
	- Boolean（）

- 对基本数据类型的值去调用属性和方法时

	- 浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法
	- 调用完以后，在将其转换为基本数据类型

- 缺点

	- ===

- String相关方法

	- 在底层字符串是以数组的形式保存的

		- 操作数组

	- length属性
	- charAt（）

		- 返回指定位置的字符
		- 等于  str【】

	- charCodeAt（）

		- 返回指定位置的字符的utf编码

	- String . fromCharCode（）

		- 根据字符编码获取字符

	- concat（）

		- 连接两个和多个字符串
		- 等于  +

	- indexOf（char，num）

		- 检索一个字符串是否含有指定内容

			- 返回第一次出现的索引

		- char：要查找的字符
		- num：从第几个字符开始查找

	- lastIndexOf（）

		- 从后往前找

	- slice（）

		- 截取字符串指定内容（切片）

	- substring（）

		- 截取字符串，类似slice
		- 不同点

			- 不能接收负值，负值默认为0
			- 会自动调整参数的位置（第一个参数 > 第二个参数 ）

	- substr（pos，len）

		- 截取字符串
		- pos：开始截取位置
		- len：截取长度

	- split（）

		- 将字符串拆分为数组
		- 需要一个字符串作为参数

			- 作为分隔的字符

	- toUpperCase（）

		- 将字符串转换为大写

	- toLowerCase（）

		- 小写

	- ===========================================字符串与正则表达式===========================================
	- split（）

		- 传递正则表达式作为参数拆分
		- 不使用全局匹配也会全局拆分

	- search（）

		- 搜索字符串是否含有指定内容（类似indexOf）
		- 可接收正则表达式
		- 没有全局匹配，只查第一个

	- match（）

		- 可以根据正则表达式从一个字符串中将符合条件的内容提取出来
		- 默认情况下只会找到第一个

			- 设置全局匹配

		- 返回一个封装的数组

	- replace（）

		- 将字符串指定内容替换为新的内容
		- 可接受正则表达式
		- 默认只替换第一个

			- 设置全局匹配

### 正则表达式

- 简介

	- 作用

		- 用于定义一些字符串规则
		- 计算机可根据正则表达式，来检查一个字符串是否符合规则
		- 获取将字符串中符合规则的内容提取出来

	- 规范

		- 严格区分大小写

- 语法

	- 创建正则表达式对象

		- 构造函数法（灵活）

			- var  变量 = new  RegExp（‘正则表达式’ ，‘匹配模式’）

		- 使用字面量（简单）

			- var 变量 = /正则表达式/匹配模式

	- 关系符

		- |

			- 或

		- 【】

			- [ a b ]  ==  a | b
			- [ A - z ]

				- 任意字母

			- /a【bde】c/  == /abc|adc|aec/
			- 【0-9】

				- 任意数字

			- ^

				- 除了（非）

	- 量词

		- 设置内容出现的次数
		- 只对其前面的内容起作用
		- { }

			- {n}  正好出现n次
			- { 1, 3 }   出现1到3次

				- { 1，}   1次以上

		- +

			- 至少一个，相当于{1，}

		- *

			- 0个或多个，相当于{0，}

		- ？

			- 0个或1个，相当于{0,  1}

		- ^

			- 表示开头
			- ^ a

				- 表示以a开头

		- $

			- 表示结尾
			- a $

				- 表示以a结尾

	- 匹配模式

		- ’ i ‘

			- 忽略大小写

		- ‘ g ’

			- 全局匹配模式

		- 可设置多个匹配模式

	- 元字符

		- .

			- 表示任意字符

		- \

			- 转义字符
			- 在构造函数中需要写成  \\

		- \w

			- 表示任意字母、数字、下划线

				- 【A-z0-9_】

		- \W

			- 非\w

				- [^A-z0-9_]

		- \d

			- 表示任意数字

				- 【0-9】

		- \D

			- 除了数字

				- 【^0-9】

		- \s

			- 空格

				- str.replace(/^\s* | \s*$/g,'')

					- 去除开头与结尾的空格

		- \S

			- 除了空格

		- \b

			- 单词边界
			- / \b child \b /

				- 表示单词两边不能有其他字符紧挨

		- \B

			- 除了单词边界

- 方法

	- test（）

		- 检查字符串是否符合正则表达式规则
		- 返回Boolean

## 进阶

### DOM

- 简介

	- document  Object  Model 文档对象模型

		- 文档

			- 整个的html网页文档

		- 对象

			- 将网页中的每一个部分都转换为一个对象

		- 模型

			- 使用模型（树）来表示对象之间的关系，方便获取对象

	- js通过DOM对html文档进行操作

- 节点Node

	- 概念

		- 是构成网页的最基本的组成部分，网页中的每一个部分都可以成为是一个节点

			- 子主题 1

	- 分类

		- 文档节点

			- 整个HTML文档
			- 浏览器提供的文档节点对象：window属性

		- 元素节点

			- HTML文档中的HTML标签（<p>）

		- 属性节点

			- 元素的属性(id、class)

		- 文本节点

			- HTML标签中的文本内容

	- 节点的属性

- 事件

	- 概念

		- 文档或浏览器窗口中发生的一些特定的交互瞬间（交互行为）
		- js与html之间的交互是通过事件实现的
		- 代表性事件（web应用）

			- 点击某元素、鼠标移至某元素上、按下键盘某个键等

	- 处理事件

		- 在事件对应的属性中设置一些js代码，当事件被触发时，代码执行
		- 位置

			- 写在html标签属性中（不推荐）
			- 写在js中

				- 获取对象

					- document.getElementById

				- 绑定处理函数形式

					- ‘xxx响应函数’
					- 事件在响应函数中，响应函数绑定的是谁，this就是谁

	- 文档加载

		- 浏览器加载页面时，是自上而下执行
		- 如果script标签写到上面，代码执行时，页面还没加载
		- 所以js代码一般写下面
		- onload事件

			- 在整个页面加载完成之后触发
			- 给window对象绑定该事件

				- 该事件对应的响应函数将会在页面加载完毕后执行

			- 可能影响性能

- PS

	- 超链接a

		- 点击超链接以后，超链接会跳转页面，这个是超链接的默认行为，但是此时我们不希望出现默认行为，可以通过在响应函数的最后return false来取消默认行为

	- confirm()

		- 用于弹出一个带有确认和取消按钮的提示框

- dom查询

	- 获取元素节点

		- 通过document对象调用

			- 方法

				- getElementById（）
				- getElementsByTagName（）

					- 通过标签名获取一组元素节点对象
					- 返回一个类数组对象

				- getElementsByName（）

					- 通过name属性获取一组元素节点对象

			- 属性

				- innerHtml属性

					- 获取元素内部的HTML代码
					- 对自结束标签无效

				- innerText

					- 与innerHtml类似，但会自动去除标签

				- 读取元素节点属性

					- 元素 . 属性名 
					- class属性不能采用此方式

						- 使用  . className

	- 获取元素节点的子节点

		- 通过具体的元素节点调用

			- 方法

				- getElementsByTagName（） 

					- 返回当前节点的指定标签名后代节点

			- 属性

				- childNodes

					- 当前节点的所有子节点（包括文本节点、标签间的空白）

						- ie8以下版本包含包含标签间的空白

				- children

					- 只返回所有子元素

				- firstChild

					- 第一个子节点（包括空白、文本节点）

				- firstElementChild

					- 第一个子节点（不兼容ie8及以下）

				- lastChild

					- 最后一个子节点

	- 获取父节点和兄弟节点

		- 通过具体的元素节点调用

			- 属性

				- parentNode

					- 表示当前节点的父节点

				- previousSibling

					- 当前节点的前一个兄弟节点
					- 也会获取空白文本

				- 				previousElementSibling;

					- 不会获取空白文本
					- 不兼容ie8及以下

				- nextSibling

					- 当前节点的后一个兄弟节点

	- 其他方法

		- 获取body标签

			- document . body

		- 获取html根标签

			- document . documentElement

		- 获取页面中所有元素

			- document . all
			- getElementsByTagName（） 

		- 根据class属性值查询一组节点对象

			- getElementsByClassName（）
			- 不兼容ie8

		- document.querySelector（）

			- 根据css选择器查询节点对象
			- 使用该方法只会返回唯一一个元素（有多个只会返回第一个）

		- document.querySelectorAll（）

			- 返回一个数组

- dom增删改

	- document方法

		- createElement（）

			- 创建元素节点对象--参数：标签名

		- TEXT_NODE()

			- 创建文件节点对象--参数：文本内容

		- 向一个父节点添加一个新的子节点

			- appendChild（）

				- 语法：父节点 . appendChild（子节点）

			- innerHTML属性

				- city.innerHTML += "<li>广州</li>"
				- var li = document.getElementById("li");
li.innerHTML = "广州";
city.appendChild(li);

					- 推荐

		- insertBefore（）

			- 在指定子节点之前插入一个新子节点（必须有父节点，且由父节点调用）
			- 父节点 . insertBefore（新节点，旧节点）

		- replaceChild（）

			- 使用新子节点替换旧子节点，语法同上

		- removeChild（）

			- 删除子节点
			- 父节点 . removeChild（子节点）
			- 子节点 . parent . removeChild（子节点）；

				- 不需要获取父节点

- dom操作样式

	- 操作内联样式：style

		- 通过js修改元素的样式

			- 语法

				- 元素 . style . 样式名 = 样式值
				- 样式值是字符串

			- 如果css样式中含有  ’ - ‘号，去减号，改为驼峰命名
			- 本质：实际修改的是内联样式，优先级较高

		- 读取元素（内联）样式

			- 语法

				- 元素 . style . 样式名

			- 只能读取内联样式

		- 通过style属性读取和修改的样式都是内联样式

	- 获取元素当前样式

		- currentStyle

			- 语法

				- 元素 . currentStyle . 样式名

			- 不兼容

				- 只有ie支持

		- getComputedStyle（参数1，参数2）

			- 属于window的方法
			- 参数1：要获取样式的元素
			- 参数2：可以传递一个伪元素，一般传null
			- 返回一个对象，该对象封装了元素的对应的样式
			- 不兼容ie8及以下

		- 自定义函数

			- 目的：兼容所有浏览器
			- function getsyle(obj, stylename){ 
            if(window.getComputedStyle){
                //正常浏览器
                return getComputedStyle(obj, null)[stylename];
            }else{
                //ie8
                return obj.currentStyle[stylename];
            }
        }

			  function getsyle(obj, stylename){ 
			              if(window.getComputedStyle){
			                  //正常浏览器
			                  return getComputedStyle(obj, null)[stylename];
			              }else{
			                  //ie8
			                  return obj.currentStyle[stylename];
			              }
			          }

			- window.getComputedStyle

				- 兼容ie8及以下
				- 若不加window，ie8会将getCS识别为普通变量

	- 其他样式相关的属性

		- 这些属性都不带px ，返回都是一个数字，可直接进行计算
		- 都只读
		- clientWidth、clientHeight

			- 获取元素的可见宽度和高度
			- 包括内容区和内边距

		- offsetHeight、offsetWidth

			- 全部宽高，包括内容区、内边距，边框

		- offsetParent

			- 获取当前元素的定位父元素
			- 最近的开启了定位的祖先元素

		- offsetLeft、offsetTop

			- 当前元素相对于其定位父元素的水平、垂直偏移量

		- scrollHeight、scroWidth

			- 返回元素的整体宽度、高度（包括滚动区里）

		- scrollLeft、scrollTop

			- 获取水平/垂直滚动条滚动的距离

		- onscroll事件

			- 该事件会在元素的滚动条滚动时触发

- 事件

	- 事件对象

		- 定义

			- 当事件响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数

				- ie8及以下不传参，而是把事件对象作为window的属性

			- 在事件对象中封装了当前事件相关的一切信息

				- 如：鼠标的坐标，键盘被按下...

		- 属性

			- clientX、clientY

				- 获取鼠标的水平、垂直坐标（可见窗口）

					- event.clientY

			- pageX、pageY

				- 获取鼠标当前页面的坐标

					- 不兼容ie8

	- 事件冒泡Bubble

		- 定义

			- 事件的向上传导，当后代元素的事件被触发时，其祖先元素的相同事件也会被触发
			- 在开发时，冒泡一般是有利的

		- 通过事件对象取消冒泡

			- event.cancelBubble = true;

		- 应用

			- 事件的委派

				- 将事件绑定给共同的祖先元素，当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件
				- 减少绑定的次数，提高性能
				- target属性

					- event中的target表示触发事件的对象
					- event.target.className == 'link'

	- 事件的绑定

		- 方法一

			- 对象 . 事件 = 响应函数
			- 缺点：只能同时为一个元素的一个事件绑定一个响应函数

		- 方法二

			- addEventListener（）

				- 参数一：事件的字符串，不要加“on”
				- 参数二：回调函数，事件触发时被调用
				- 参数三：是否在捕获阶段触发（true/false）

			- 该方法中的this，是绑定事件的对象
			- 可同时为一个元素的相同事件同时绑定多个响应函数
			- 兼容ie8

				- attachEvent（）

					- 参数1：事件的字符串，要“on”
					- 参数2：回调函数

				- 该方法的this，是window
				- 执行顺序相反

		- 方法三

			- 自定义函数

				- function bd(obj,eventstr,callback){
            if(obj.addEventListener){
               //大部分浏览器兼容
                obj.addEventListener(eventstr, callback, false); 
            }else{
                //ie8及以下
                obj.attachEvent("on"+eventstr, function(){
                    //改变this指向
                    //调用回调函数
                    callback.call(obj);
                });
            }           
  }

	- 事件的传播

		- 定义

			- 微软

				- 事件应该是由内向外传播

					- 在冒泡阶段执行

			- 网景

				- 事件是由外向内传播的（先祖先，后自己）

					- 捕获阶段

			- W3C

				- 综合两个公司方案
				- 事件传播的三个阶段（ie9及以上）

					- 1、捕获阶段

						- 此阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
						- 如果希望在此阶段触发事件，将addEventListener的第三个参数设置为true

					- 2、目标阶段

						- 事件捕获到目标元素，捕获结束开始在目标元素上触发事件

					- 3、冒泡阶段

						- 事件从目标元素向他的祖先元素传递，分别依次触发祖先元素上的事件

	- 事件练习

		- 拖拽

			- 流程

				- 1.当鼠标按下时，开始拖拽：onmousedown
2.鼠标移动，元素被拖动：onmousemove
3.鼠标松开，被拖拽元素固定：onmouseup

			- 优化

				- 鼠标位置

					- div的偏移量 鼠标.clientX - 元素.offsetLeft
div的偏移量 鼠标.clientY - 元素.offsetTop

				- 拖拽内容时，浏览器会默认去搜索引擎中搜索内容

					- return false

						- 不兼容ie8

					- setCapture（）方法

						- chrome不支持

					- setPointerCapture属性
					- releasePointerCapture属性

				- 提取拖拽函数

		- 滚轮事件

			- onmousewheel鼠标滚轮事件

				- 火狐不兼容

					- 需要使用DOMMouseScroll来绑定
					- 需要addEventListener（）来绑定

			- 属性

				- event . wheelDelta

					- 获取鼠标滚动的方向（150px/次）
					- 火狐不兼容

				- event . detail

					- 火狐兼容

			- 优化

				- 当滚轮滚动时，如果浏览器有滚动条，浏览器页面会随之滚动

					- 这是浏览器的默认行为
					- 取消

						-  return false

							- 火狐不兼容

						- 使用event取消

							- preventDefault（）

								- ie8不兼容

						- event.preventDefault && event.preventDefault();

		- 键盘事件

			- 事件

				- onkeydown

					- 按键被按下
					- 如果一直不松手，事件会一直触发

						- 当down连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常快

							- 防止误操作

					- 文本框输入内容时down的默认内容，不能使用return false，否则输入的内容不会出现在文本

						- 使文本框中不能输入数字

							- if(event.keyCode <= 57 && event.keyCode >= 48){
                    return false;
                }

				- onkeyup

					- 按键松开
					- 不会连续触发

			- event属性

				- event . keyCode

					- 获取按键的编码

						- 判断按下哪个按键

				- altKey、ctrlKey、shiftKey

					- 判断这三个键是否被按下
					- 返回true/false
					- 用于组合按键

			- 键盘事件一般都会绑定给一些可以获取到焦点的对象或document对象

				- 表单、文档

			- 练习：键盘控制元素移动

				- 左上右下：37/38/39/40

### BOM

- 简介

	- 浏览器对象模型 
	- 可以通过 js 操作浏览器
	- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作

- BOM对象

	- Window

		- 代表的是整个浏览器的窗口，同时window也是网页中的全局对象

	- Navigator

		- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器

	- Location

		- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面

	- History

		- 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
		- 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效

	- Screen

		- 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

- Navigator

	- 简介

		- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
		- 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了

	- 对象属性

		- userAgent（用户代理、浏览器）

			- 判断浏览器的信息

				- Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36

			- 是一个字符串，这个字符串中包含有用来描述浏览器信息的内容
			- 不同的浏览器会有不同的userAgent
			- 注：在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了

		- ActiveXObject

			- 如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
			- 是一个构造函数
			- 只支持ie
			- "ActiveXObject" in window

				- 检查一个对象是否含有某属性

- history

	- 对象可以用来操作浏览器向前或向后翻页
	- length

		- 属性，可以获取到当成访问的链接数量

	- back（）

		- 可以用来回退到上一个页面，作用和浏览器的回退按钮一样

	- forward（）

		- 可以跳转下一个页面，作用和浏览器的前进按钮一样

	- go（）

		- 可以用来跳转到指定的页面
		- 需要一个整数作为参数

			- 1:  表示向前跳转一个页面 相当于forward()
2:  表示向前跳转两个页面
-1:  表示向后跳转一个页面
-2:  表示向后跳转两个页面

- Location

	- 该对象中封装了浏览器的地址栏的信息

		- 如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）

	- 如果直接将location属性修改为一个完整的路径，或相对路径，则我们页面会自动跳转到该路径，并且会生成相应的历史记录

		- location = "http://www.baidu.com";

	- 属性

		- 地址栏的各个部分

	- 方法

		- assign（）

			- 用来跳转到其他的页面，作用和直接修改location一样

		- reload（）

			- 用于重新加载当前页面，作用和刷新按钮一样
			- 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面

				- 等于 Ctrl + F5

		- replace（）

			- 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
			- 不会生成历史记录，不能使用回退按钮回退

- 定时事件

	- setInterval（）

		- 定时调用

			- 可以将一个函数，每隔一段时间执行一次

		- 参数

			- 1.回调函数，该函数会每隔一段时间被调用一次
			- 2.每次调用间隔的时间，单位是毫秒

		- 返回值

			- 返回一个Number类型的数据
			- 这个数字用来作为定时器的唯一标识

	- setInterval()
	- clearInterval(timer);

		- 关闭定时器
		- 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
		- 一般在开启定时器前需要先设置关闭定时器

	- 应用

		- 练习1：图片自动切换效果
		- 练习2：移动div优化
		- 练习3：点击按钮后，div元素移动

- 延时事件

	- 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次

		- 延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
		- 延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择

	- setTimeout（）
	- clearTimeout（）

		- 关闭一个延时调用

- 类的操作

	- 引入

		- box1.style.width
		- 每修改一次样式，浏览器就要重新渲染一次页面，影响性能；且修改多个样式很不方便

	- 间接修改法

		- 修改元素的class属性
		- 浏览器只需要重新渲染一次
		- 使表现与行为进一步分离
		- box1.className = "b2";

			- box1原class为 b1

		- 或box1.className += “  b2” 

			- 在b1的基础上扩展b2样式

	- 添加类

		- 定义一个函数，用来向一个元素中添加指定的class属性值

			- function addClass(obj, cn){
            //检查obj中是否含有cn
            if(!hasClass(obj, cn)){
                obj.className += " "+cn;
            }          
        }

	- 判断类

		- 判断一个元素是否含有指定class属性值

			- function hasClass(obj, cn){
            //判断obj中是否含有cn类
            //创建正则表达式
            // var reg = /\bb2\b/;
            var reg = new RegExp("\\b"+cn+"\\b");
            return reg.test(obj.className);
        }

	- 删除类

		- 删除元素中指定的class属性

			- function rmClass(obj, cn){
            //创建一个正则表达式
            var reg = new RegExp("\\b"+cn+"\\b");
            //删除cn
            obj.className = obj.className.replace(reg, "");
        }

	- 切换类

		- 如果元素中有该类，则删除；如果没有该类，则添加

			- function toggleClass(obj, cn){
            if(hasClass(obj, cn)){
                rmClass(obj, cn);
            }else{
                addClass(obj, cn);
            }
        }

- 事件练习

	- 轮播图

		- 功能

			- 单击导航点切换到指定图片
			- 图片自动切换

	- 二级菜单

- JSON

	- 简介

		- JavaScript  Object  Notation   Js对象表示法
		- js中的对象只有js自己认识，其他语言都不认识
		- 需求：把对象转换成所有语言都认识的代码

	- 定义

		- JSON就是一个特殊格式的字符串，可以被任意语言识别
		- 且可以转换为任意语言中的对象

	- 作用

		- 在开发中主要用来数据的交互

	- 语法

		- JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号
		- 其他一致

	- 分类

		- 对象

			- { }

		- 数组

			- [  ]

	- 允许的值

		- 字符串
		- 数组
		- 布尔值
		- null
		- 对象

			- 普通对象
			- 不能是函数对象

		- 数组

	- JSON 工具类

		- 将json字符串转换为js中的对象
		- 方法

			- parse（）

				- 将json字符串转换为js中的对象
				- 参数：JSON字符串
				- 对象的key必须加引号

					- js代码中原本可加可不加

			- stringify（）

				- JS  →  JSON 

		- 兼容处理

			- ie7及以下不兼容
			- eval（）函数

				- 可以用来执行一段字符串形式的JS代码，并将执行结果返回
				- 如果函数中的字符串含有 { }，它会将 { }当成代码块

					- 如果不希望当成代码块解析，需要在字符串前后加括号

				- 功能强大，但是开发中尽量不要使用

					- 性能差
					- 具有安全隐患

			- 引入外部js文件处理

				- <script src="../js/json2.js"></script>

# JavaScript高级1.0

## 一、基础部分

### 数据类型的分类和判断

* 基本(值)类型
  * Number ----- 任意数值 -------- typeof
  * String ----- 任意字符串 ------ typeof
  * Boolean ---- true/false ----- typeof
  * undefined --- undefined ----- typeof/===
  * null -------- null ---------- ===
* 对象(引用)类型
  * Object ----- typeof/instanceof
  * Array ------ instanceof
  * Function ---- typeof

### 数据,变量, 内存的理解

* 什么是数据?
  * 在内存中可读的, 可传递的保存了特定信息的'东东'
  * 一切皆数据, 函数也是数据
  * 在内存中的所有操作的目标: 数据
* 什么是变量?
  * 在程序运行过程中它的值是允许改变的量
  * 一个变量对应一块小内存, 它的值保存在此内存中  
* 什么是内存?
  * 内存条通电后产生的存储空间(临时的)
  * 一块内存包含2个方面的数据
    * 内部存储的数据
    * 地址值数据
  * 内存空间的分类
    * 栈空间: 全局变量和局部变量
    * 堆空间: 对象 
* 内存,数据, 变量三者之间的关系
  * 内存是容器, 用来存储不同数据
  * 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  

### 对象的理解和使用

* 什么是对象?

  * 多个数据(属性)的集合
  * 用来保存多个数据(属性)的容器

* 属性组成:

  * 属性名 : 字符串(标识)
  * 属性值 : 任意类型

* 属性的分类:

  * 一般 : 属性值不是function  描述对象的状态
  * 方法 : 属性值为function的属性  描述对象的行为

* 特别的对象

  * 数组: 属性名是0,1,2,3之类的索引
  * 函数: 可以执行的

* 如何操作内部属性(方法)

  * .属性名

  * ['属性名']: 属性名有特殊字符/属性名是一个变量

### 函数的理解和使用

* 什么是函数?

  * 用来实现特定功能的, n条语句的封装体
  * 只有函数类型的数据是可以执行的, 其它的都不可以

* 为什么要用函数?

  * 提高复用性
  * 便于阅读交流

* 函数也是对象

  * instanceof Object===true
  * 函数有属性: prototype
  * 函数有方法: call()/apply()
  * 可以添加新的属性/方法

* 函数的3种不同角色

  * 一般函数 : 直接调用
  * 构造函数 : 通过new调用
  * 对象 : 通过.调用内部的属性/方法

* 函数中的this

  * 显式指定谁: obj.xxx()
  * 通过call/apply指定谁调用: xxx.call(obj)
  * 不指定谁调用: xxx()  : window
  * 回调函数: 看背后是通过谁来调用的: window/其它

* 匿名函数自调用:

  ```
  (function(w, obj){
    //实现代码
  })(window, obj)
  ```

  * 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式						  

* 回调函数的理解

  * 什么函数才是回调函数?
    * 你定义的
    * 你没有调用
    * 但它最终执行了(在一定条件下或某个时刻)
  * 常用的回调函数
    * dom事件回调函数
    * 定时器回调函数
    * ajax请求回调函数(后面讲解)
    * 生命周期回调函数(后面讲解)





## 二、函数高级

### 原型与原型链

* 所有函数都有一个特别的属性:
  * `prototype` : 显式原型属性
* 所有实例对象都有一个特别的属性:
  * `__proto__` : 隐式原型属性
* 显式原型与隐式原型的关系
  * 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象
  * 实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
  * 原型对象即为当前实例对象的父对象
* 原型链
  * 所有的实例对象都有__proto__属性, 它指向的就是原型对象
  * 这样通过__proto__属性就形成了一个链的结构---->原型链
  * 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
  * 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作

### 执行上下文与执行上下文栈

* 变量提升与函数提升
  * 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
  * 函数提升: 在函数定义语句之前, 就执行该函数
  * 先有变量提升, 再有函数提升
* 理解
  * 执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性
  * 执行上下文栈: 用来管理产生的多个执行上下文
* 分类:
  * 全局: window
  * 函数: 对程序员来说是透明的
* 生命周期
  * 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
  * 函数 : 调用函数时产生, 函数执行完时死亡
* 包含哪些属性:
  * 全局 : 
    * 用var定义的全局变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===>window
  * 函数
    * 用var定义的局部变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===> 调用函数的对象, 如果没有指定就是window 
    * 形参变量   ===>对应实参值
    * arguments ===>实参列表的伪数组
* 执行上下文创建和初始化的过程
  * 全局:
    * 在全局代码执行前最先创建一个全局执行上下文(window)
    * 收集一些全局变量, 并初始化
    * 将这些变量设置为window的属性
  * 函数:
    * 在调用函数时, 在执行函数体之前先创建一个函数执行上下文
    * 收集一些局部变量, 并初始化
    * 将这些变量设置为执行上下文的属性

### 作用域与作用域链

* 理解:
  * 作用域: 一块代码区域, 在编码时就确定了, 不会再变化
  * 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
* 分类:
  * 全局
  * 函数
  * js没有块作用域(在ES6之前)
* 作用
  * 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
  * 作用域链: 查找变量
* 区别作用域与执行上下文
  * 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
  * 执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失
  * 联系: 执行上下文环境是在对应的作用域中的

### 闭包 

* 理解:

  * 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
  * 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性

* 作用:

  * 延长局部变量的生命周期
  * 让函数外部能操作内部的局部变量

* 写一个闭包程序

  ```
  function fn1() {
    var a = 2;
    function fn2() {
      a++;
      console.log(a);
    }
    return fn2;
  }
  var f = fn1();
  f();
  f();
  ```

* 闭包应用:

  * 模块化: 封装一些数据以及操作数据的函数, 向外暴露一些行为
  * 循环遍历加监听
  * JS框架(jQuery)大量使用了闭包

* 缺点:

  * 变量占用内存的时间可能会过长
  * 可能导致内存泄露
  * 解决:
    * 及时释放 : f = null; //让内部函数对象成为垃圾对象

### 内存溢出与内存泄露

1. 内存溢出

  * 一种程序运行出现的错误
  * 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误

2. 内存泄露

  * 占用的内存没有及时释放
  * 内存泄露积累多了就容易导致内存溢出
  * 常见的内存泄露:
    * 意外的全局变量
    * 没有及时清理的计时器或回调函数
    * 闭包





## 三、对象高级

### 对象的创建模式

* Object构造函数模式

  ```
  var obj = {};
  obj.name = 'Tom'
  obj.setName = function(name){this.name=name}
  ```

* 对象字面量模式

  ```
  var obj = {
    name : 'Tom',
    setName : function(name){this.name = name}
  }
  ```

* 构造函数模式

  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
    this.setName = function(name){this.name=name;};
  }
  new Person('tom', 12);
  ```

* 构造函数+原型的组合模式

  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  Person.prototype.setName = function(name){this.name=name;};
  new Person('tom', 12);
  ```

### 继承模式

* 原型链继承 : 得到方法

  ```
  function Parent(){}
  Parent.prototype.test = function(){};
  function Child(){}
  Child.prototype = new Parent(); // 子类型的原型指向父类型实例
  Child.prototype.constructor = Child
  var child = new Child(); //有test()
  ```

* 借用构造函数 : 得到属性

  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  var child = new Child('a', 'b');  //child.xxx为'a', 但child没有test()
  ```

* 组合

  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  Child.prototype = new Parent(); //得到test()
  var child = new Child(); //child.xxx为'a', 也有test()
  ```

* new一个对象背后做了些什么?

  * 创建一个空对象
  * 给对象设置__proto__, 值为构造函数对象的prototype属性值   this.__proto__ = Fn.prototype
  * 执行构造函数体(给对象添加属性/方法)





## 四、线程机制与事件机制

### 线程与进程

* 进程:
  * 程序的一次执行, 它占有一片独有的内存空间
  * 可以通过windows任务管理器查看进程
* 线程:
  * 是进程内的一个独立执行单元
  * 是程序执行的一个完整流程
  * 是CPU的最小的调度单元
* 关系
  * 一个进程至少有一个线程(主)
  * 程序是在某个进程中的某个线程执行的

### 浏览器内核模块组成

* 主线程
  * js引擎模块 : 负责js程序的编译与运行
  * html,css文档解析模块 : 负责页面文本的解析
  * DOM/CSS模块 : 负责dom/css在内存中的相关处理 
  * 布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)
* 分线程
  * 定时器模块 : 负责定时器的管理
  * DOM事件模块 : 负责事件的管理
  * 网络请求模块 : 负责Ajax请求

### js线程

* js是单线程执行的(回调函数也是在主线程)
* H5提出了实现多线程的方案: Web Workers
* 只能是主线程更新界面

### 定时器问题:

* 定时器并不真正完全定时
* 如果在主线程执行了一个长时间的操作, 可能导致延时才处理

### 事件处理机制(图)

* 代码分类
  * 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
  * 回调执行代码: 处理回调逻辑
* js引擎执行代码的基本流程: 
  * 初始化代码===>回调代码
* 模型的2个重要组成部分:
  * 事件管理模块
  * 回调队列
* 模型的运转流程
  * 执行初始化代码, 将事件回调函数交给对应模块管理
  * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
  * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

### H5 Web Workers

* 可以让js在分线程执行

* Worker

  ```
  var worker = new Worker('worker.js');
  worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调
  worker.postMessage(data1) : 向另一个线程发送数据
  ```

* 问题:

  * worker内代码不能操作DOM更新UI
  * 不是每个浏览器都支持这个新特性
  * 不能跨域加载JS

* svn版本控制

* svn server



# JavaScript高级2.0

### 基础总结深入

- 数据类型

  1. 分类(2大类)

    * 基本(值)类型
      * Number: 任意数值
      * String: 任意文本
      * Boolean: true/false
      * undefined: undefined
      * null: null
    * 对象(引用)类型
      * Object: 一般对象类型
      * Array: 特别的对象类型(下标/内部数据有序)
      * Function: 特别的对象类型(可执行)

  2. 判断

    * typeof:
      * 可以区别: 数值, 字符串, 布尔值, undefined, function
      * 不能区别: null与对象, 一般对象与数组
    * instanceof
      * 专门用来判断对象数据的类型: Object, Array与Function
    * ===
      * 可以判断: undefined和null

  - 1. 分类

    - 基本(值)类型

      - Number: 任意数值
      - String: 任意文本
      - Boolean: true/false
      - undefined: undefined
      - null: null

    - 对象(引用)类型

      - Object: 一般对象类型
      - Array: 特别的对象类型(下标/内部数据有序)
      - ⑧  Function: 特别的对象类型(可执行)

  - 2. 判断

    - typeof

      - 打印字符串
      - 可以区别

        - 数值, 字符串, 布尔值, undefined, function

      - 不能区别

        - null与对象, 一般对象与数组

    - instanceof

      - 专门用来判断对象数据的类型

        - Object, Array与Function

    - ===

      - 可以判断: undefined和null

  - 相关问题

    1. undefined与null的区别?

      * undefined代表变量没有赋值
      * null: 代表变量赋值了, 只是值为null

    2. 什么时候将变量赋值为null?

      * 初始化赋值: 将要作为引用变量使用, 但对象还没有确定
      * 结束时: 将变量指向的对象成为垃圾对象

    3. 理解变量类型与数据类型?

      * js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型
      * 变量类型:
        * 基本类型: 保存基本类型数据的变量
        * 引用类型: 保存对象地址值的变量
      * 数据对象
        * 基本类型
        * 对象类型

    - 1. undefined与null的区别?

      - undefined代表变量没有赋值
      - null: 代表变量赋值了, 只是值为null

    - 2. 什么时候将变量赋值为null?

      - 初始化赋值: 将要作为引用变量使用, 但对象还没有确定
      - 结束时: 将变量指向的对象成为垃圾对象（被垃圾回收器回收）

    - 3. 严格区别变量类型与数据类型?

      - js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型

        - 变量 = 值

          - 即 “变量”没有数据类型，“值”拥有数据类型

      - 变量类型

        - 基本类型: 保存基本类型数据的变量
        - 引用类型: 保存对象地址值的变量

      - 数据对象

        - 基本类型
        - 对象类型

- 数据, 变量与内存

  1. 什么是数据?

    * 存储于内存中代表特定信息的'东东', 本质就是0101二进制
    * 具有可读和可传递的基本特性
    * 万物(一切)皆数据, 函数也是数据
    * 程序中所有操作的目标: 数据
      * 算术运算
      * 逻辑运算
      * 赋值
      * 调用函数传参
        ...

  2. 什么是内存?

    * 内存条通电后产生的存储空间(临时的)
    * 产生和死亡: 内存条(集成电路板)==>通电==>产生一定容量的存储空间==>存储各种数据==>断电==>内存全部消失
    * 内存的空间是临时的, 而硬盘的空间是持久的
    * 分配内存: 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据
    * 释放内存: 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用)
      * 自动释放: 栈空间的局部变量
      * 垃圾回调器回调: 堆空间的垃圾对象
    * 一块内存包含2个数据
      * 内部存储的数据(一般数据/地址数据)
      * 内存地址值数据
    * 内存分类
      * 栈: 全局变量, 局部变量 (空间较小)
      * 堆: 对象 (空间较大)

  3. 什么是变量?

    * 值可以变化的量, 由变量名与变量值组成
    * 一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容

  4. 内存,数据, 变量三者之间的关系

    * 内存是一个容器, 用来存储程序运行需要操作的数据
    * 变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据

  - 1. 什么是数据?

    - 存储于内存中代表特定信息的'东东', 本质就是0101二进制
    - 具有可读和可传递的基本特性
    - 万物(一切)皆数据, 函数也是数据
    - 程序中所有操作的目标: 数据

      - 算术运算
      - 逻辑运算
      - 调用函数传参
      - 赋值

  - 2. 什么是内存?

    - 定义

      - 内存条通电后产生的可存储数据的空间(临时的)
      - 内存的空间是临时的, 而硬盘的空间是持久的

    - 产生和死亡

      - 内存条(集成电路板)   ==>   通电   ==>   产生一定容量的存储空间   ==>   存储各种数据   ==>   断电   ==>   内存全部消失

    - 分配与释放

      - 分配内存

        - 声明变量和函数或创建对象时, JS引擎会自动为此分配一定大小的内存来存放对应的数据

      - 释放内存

        - 清空内存中的数据, 标识内存可以再分配使用(内存不释放就不能复用)
        - 自动释放

          - 栈空间的局部变量

        - 垃圾回调器回调

          -  堆空间的垃圾对象

    - 一块内存包含2个数据

      - 内部存储的数据(一般数据/地址数据)
      - 内存地址值数据

    - 内存分类

      - 栈

        - 全局变量, 局部变量 (空间较小)

      - 堆

        - 对象 (空间较大)

  - 3. 什么是变量?

    - 定义

      - 值可以变化的量, 由变量名与变量值组成

    - 一个变量对应一块小内存, 变量名用来查找到内存, 变量值就是内存中保存的内容
    - 例：形参的本质就是变量，实参就是数据
    - 变量在 等号 的左边，就是写；变量在右边就是读

  - 4. 内存,数据, 变量三者之间的关系

    - 内存是一个容器, 用来存储程序运行需要操作的数据
    - 变量是内存的标识, 我们通过变量找到对应的内存, 进而操作(读/写)内存中的数据

  - 相关问题

    1. 问题1: var a = xxx, a内存中到底保存的是什么?

      * xxx是一个基本数据
      * xxx是一个对象
      * xxx是一个变量

    2. 关于引用变量赋值问题

      * 2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见
      * 2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象

    3. 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递?

      * 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据
      * 如果后一种看成是引用传递, 那就值传递和引用传递都可以有

    4. 问题: JS引擎如何管理内存?
      5. 内存生命周期

        1). 分配需要的内存
        2). 使用分配到的内存
        3). 不需要时将其释放/归还

        2. 释放内存

        * 为执行函数分配的栈空间内存: 函数执行完自动释放
        * 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存

    - 关于赋值与内存的问题?

      - 问题1: var a = xxx, a内存中到底保存的是什么?

  * xxx是一个基本数据

  * xxx是一个对象

  * xxx是一个变量

    	- var a = xxx
    	
    			- xxx 为 “3”  ，则a保存的是基本数据
    			- xxx 为对象，则a保存的是地址值
    			- xxx 为变量，“变量”可以是基本数据，也可以是地址值

    - 关于引用变量赋值问题?

      - 2个引用变量指向同一个对象, 通过一个引用变量修改对象内部数据, 另一个引用变量也看得见
      - 2个引用变量指向同一个对象,让一个引用变量指向另一个对象, 另一个引用变量还是指向原来的对象

    - 关于数据传递问题?

      - 问题: 在js调用函数时传递变量参数时, 是值传递还是引用传递?

        -   * 只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据
        -   *  如果后一种看成是引用传递, 那就值传递和引用传递都可以有

      - var a = 3
        function fn (a) {
        a = a +1
        }
        fn(a)

        - 传进  “3”，对“3“进行操作

      - 值传递

        - “值” 可以是基本数据；
          也可以是地址。

    - JS引擎如何管理内存?

      - 内存生命周期

        - 1). 分配需要的内存
          2). 使用分配到的内存
          3). 不需要时将其释放/归还

      - 释放内存

        - 为执行函数分配的栈空间内存

          - 函数执行完自动释放

        - 存储对象的堆空间内存

          - 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存

- 对象

  1. 什么是对象?

    * 代表现实中的某个事物, 是该事物在编程中的抽象
    * 多个数据的集合体(封装体)
    * 用于保存多个数据的容器

  2. 为什么要用对象?

    * 便于对多个数据进行统一管理

  3. 对象的组成

    * 属性
      * 代表现实事物的状态数据
      * 由属性名和属性值组成
      * 属性名都是字符串类型, 属性值是任意类型
    * 方法
      * 代表现实事物的行为数据
      * 是特别的属性==>属性值是函数

  4. 如何访问对象内部数据?

    * .属性名: 编码简单, 但有时不能用
    * ['属性名']: 编码麻烦, 但通用

  - 1. 什么是对象?

    - 代表现实中的某个事物, 是该事物在编程中的抽象
    - 多个数据的集合体(封装体)
    - 用于保存多个数据的容器

      - 优点（相对于变量）

  - 2. 为什么要用对象?

    - 便于对多个数据进行统一管理

  - 3. 对象的组成

    - 属性

      - 代表现实事物的状态数据
      - 由属性名和属性值组成
      - 属性名都是字符串类型, 属性值是任意类型

    - 方法

      - 代表现实事物的行为数据
      - 是特别的属性==>属性值是函数

  - 4. 如何访问对象内部数据?

    -  .属性名: 编码简单, 但有时不能用
    -  ['属性名']: 编码麻烦, 但通用

  - 相关问题

    什么时候必须使用['属性名']的方式访问对象内部数据?

      * 属性名不是合法的标识名
      * 属性名不确定

    - 什么时候必须使用['属性名']的方式?

      - 属性名不是合法的标识名
      - 属性名不确定

- 函数

  1. 什么是函数?

    * 具有特定功能的n条语句的封装体
    * 只有函数是可执行的, 其它类型的数据是不可执行的
    * 函数也是对象

  2. 为什么要用函数?

    * 提高代码复用
    * 便于阅读和交流

  3. 如何定义函数?

    * 函数声明
    * 表达式

  4. 调用(执行)函数

    * test()
    * new test()
    * obj.test()
    * test.call/apply(obj)

  - 1. 什么是函数?

    - 实现特定功能的n条语句的封装体
    - 只有函数是可以执行的, 其它类型的数据不能执行

  - 2. 为什么要用函数?

    - 提高代码复用
    - 便于阅读交流

      - 封装思想

  - 3. 如何定义函数?

    -  函数声明
    -  表达式

  - 4. 如何调用(执行)函数?

    - test(): 直接调用
    - obj.test(): 通过对象调用
    - new test(): new调用
    - test.call/apply(obj): 临时让test成为obj的方法进行调用

  - 5. 回调函数

    6. 什么函数才是回调函数?

      * 你定义的
      * 你没有直接调用
      * 但最终它执行了(在特定条件或时刻)

    2. 常见的回调函数?

      * DOM事件函数
      * 定时器函数

      * ajax回调函数(后面学)
      * 生命周期回调函数(后面学)

    - 1. 什么函数才是回调函数?

      - 1). 你定义的
        2). 你没有调
        3). 但最终它执行了(在某个时刻或某个条件下)

    - 2. 常见的回调函数?

      - dom事件回调函数   ==>  发生事件的dom元素
      - 定时器回调函数 ===>window

        - 超时定时器
        - 循环定时器

      - ajax请求回调函数(后面讲)
      - 生命周期回调函数(后面讲)

  - 6. IIEF

    7. 理解

      * 全称: Immediately-Invoked Function Expression 立即调用函数表达式
      * 别名: 匿名函数自调用

    2. 作用

      * 隐藏内部实现
      * 不污染外部命名空间

    - 1. 理解

      - 全称: Immediately-Invoked Function Expression 立即调用函数表达式
      - 别名: 匿名函数自调用

    - 2. 作用

      - 隐藏内部实现
      - 不污染外部命名空间
      - 编写js模块

    - (function () { //匿名函数自调用
      var a = 3
      console.log(a + 3)
      })()

    - $

      - $是一个函数
      - $执行后返回的是一个对象

  - 7. 函数中的this

    function Person(color) {
      // console.log(this)
      this.color = color;
      this.getColor = function () {
        // console.log(this)
        return this.color;
      };
      this.setColor = function (color) {
       // console.log(this)
        this.color = color;
      };
    }
    Person("red"); //this是谁?
    var p = new Person("yello"); //this是谁?
    p.getColor(); //this是谁?
    var obj = {};
    p.setColor.call(obj, "black"); //this是谁?
    var test = p.setColor;
    test(); //this是谁?
    function fun1() {
      function fun2() {
        console.log(this);
      }
      fun2(); //this是谁?
    }
    fun1();

    - this是什么?

      - 任何函数本质上都是通过某个对象来调用的,如果没有直接指定就是window
      - 所有函数内部都有一个变量this
      - 它的值是调用函数的当前对象

    - 如何确定this的值?

      - test(): window
      - p.test(): p
      - new test(): 新创建的对象
      - p.call(obj): obj

- 关于分号

  - 建议不加分号

    - 如 vue.js

  - 出现问题的情况

    - 小括号开头的前一条语句
    - 中方括号开头的前一条语句

  - 解决办法

    - 在行首家分号

### 函数高级

- 原型与原型链

  - 原型(prototype)

    1. 函数的prototype属性(图)

      * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
      * 原型对象中有一个属性constructor, 它指向函数对象

    2. 给原型对象添加属性(一般都是方法)

      * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

    - 1. 函数的protype属性

      - 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
      - 原型对象中有一个属性constructor, 它指向函数对象

    - 2. 给原型对象添加属性(一般都是方法)

      - 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

  - 显式原型与隐式原型

    1. 每个函数function都有一个prototype，即显式原型
    2. 每个实例对象都有一个__proto__，可称为隐式原型
    3. 对象的隐式原型的值为其对应构造函数的显式原型的值
    4. 内存结构(图)
    5. 总结:

      * 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
      * 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值
      * 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)

    - 显式原型(属性)

      - 每个函数function都有一个prototype

    - 隐式原型(属性)

      - 每个实例对象（new  xxx）都有一个__proto__

    - 对象的隐式原型的值为其对应构造函数的显式原型的值

      - Fn.prototype===fn.__proto__

    - 总结

      - 函数的prototype属性

        - 在定义函数时自动添加的, 默认值是一个空Object对象

          - 内部语句: this.prototype = {}

      - 对象的__proto__属性

        - 创建对象时自动添加的, 默认值为构造函数的prototype属性值

          - 内部语句: this.__proto__ = Fn.prototype

      - 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)

        - //给原型添加方法
          Fn.prototype.test = function () {
          console.log('test()')
          }

  - 原型链

    - 1. 原型链

      1. 原型链(图解)

        * 访问一个对象的属性时，
          * 先在自身属性中查找，找到返回
          * 如果没有, 再沿着__proto__这条链向上查找, 找到返回
          * 如果最终没找到, 返回undefined
        * 别名: 隐式原型链
        * 作用: 查找对象的属性(方法)

      2. 构造函数/原型/实体对象的关系(图解)
      3. 构造函数/原型/实体对象的关系2(图解)

      - 别名: 隐式原型链

        - 沿着隐式原型找

      - 作用

        - 查找对象属性

      - 访问一个对象的属性时

        - 先在自身属性中查找，找到返回
        - 如果没有, 再沿着__proto__这条链向上查找, 找到返回
        - 如果最终没找到, 返回undefined

          - 原型链的尽头：__proto__=null

    - 2. 构造函数/原型/实例对象的关系(图解)

      - var o1 = new Object();
        var o2 = {};

    - 3. 构造函数/原型/实例对象的关系2(图解)

      - function Foo(){  }
      - 所有函数的__proto__都是一样的

        - 因为所有函数都是由 “Function” new出来的

      - 函数的显示原型指向的对象默认是空object实例对象

        - 但Object不满足

          - Object . prototype instanceof Object   ==》 false

      - 所有函数都是Function的实例（包括Function本身）

        - Function.__proto__===Function.prototype

      - Object的原型对象是原型链的尽头

        - Object.prototype.__proto__==null

    - 4. 原型继承

      - 构造函数的实例对象自动拥有构造函数原型对象的属性(方法)
      - 利用的就是原型链

    - 5. 原型属性问题

      6. 读取对象的属性值时: 会自动到原型链中查找
      7. 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值
      8. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上

      - 读取对象的属性值时

        - 会自动到原型链中查找

      - 设置对象的属性值时

        - 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值

      - 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上

  - 探索instanceof

    1. instanceof是如何判断的?

      * 表达式: A instanceof B
      * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false

    2. Function是通过new自己产生的实例

    - 使用

      - 表达式: A instanceof B
      - 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false

    - Function是通过new自己产生的实例
    - 案例

      - 案例1

        - function Foo() {  }
          var f1 = new Foo();
          console.log(f1 instanceof Foo);
          console.log(f1 instanceof Object);
      - 案例2

        - console.log(Object instanceof Function);
          console.log(Object instanceof Object);
          console.log(Function instanceof Function);
          console.log(Function instanceof Object);

function Foo() {}
console.log(Object instanceof  Foo);
	- 面试题

	  /*
	    测试题1
	     */
	    var A = function() {
	    }
	    A.prototype.n = 1
	    var b = new A()
	    A.prototype = {
	      n: 2,
	      m: 3
	    }
	    var c = new A()
	    console.log(b.n, b.m, c.n, c.m)
	    /*
	     测试题2
	     */
	    var F = function(){};
	    Object.prototype.a = function(){
	      console.log('a()')
	    };
	    Function.prototype.b = function(){
	      console.log('b()')
	    };
	    var f = new F();
	    f.a()
	    f.b()
	    F.a()
	    F.b()
	
		- 面试题1
	
			- 

  var A = function() {

  }
  A.prototype.n = 1
  var b = new A()
  A.prototype = {
    n: 2,
    m: 3
  }
  var c = new A()
  console.log(b.n, b.m, c.n, c.m)

答案：1  undefined   2   3

		- 面试题2
	
			- var F = function(){};

  Object.prototype.a = function(){
    console.log('a()')
  };
  Function.prototype.b = function(){
    console.log('b()')
  };
  var f = new F();
  f.a()    //  a()
  f.b()    //  error
  F.a()   //   a()
  F.b()   //   b()

- 执行上下文与执行上下文栈

  - 变量提升与函数提升

    1. 变量声明提升

      * 通过var定义(声明)的变量, 在定义语句之前就可以访问到
      * 值: undefined

    2. 函数声明提升

      * 通过function声明的函数, 在之前就可以直接调用
      * 值: 函数定义(对象)

    3. 问题: 变量提升和函数提升是如何产生的?

    - 变量声明提升

      - 通过var定义(声明)的变量, 在定义语句之前就可以访问到
      - 值: undefined

    - 函数声明提升

      - 通过function声明的函数, 在之前就可以直接调用

        - 区别

          - function fn2() {}

            - 可调用  函数提升

          - var fn3 = function () {}

            - 不能  变量提升

      - 值: 函数定义(对象)

    - 问题: 变量提升和函数提升是如何产生的?

  - 执行上下文

    1. 代码分类(位置)

      * 全局代码
      * 函数代码

    2. 全局执行上下文

      * 在执行全局代码前将window确定为全局执行上下文
      * 对全局数据进行预处理
        * var定义的全局变量==>undefined, 添加为window的属性
        * function声明的全局函数==>赋值(fun), 添加为window的方法
        * this==>赋值(window)
      * 开始执行全局代码

    3. 函数执行上下文

      * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象
      * 对局部数据进行预处理
        * 形参变量==>赋值(实参)==>添加为执行上下文的属性
        * arguments==>赋值(实参列表), 添加为执行上下文的属性
        * var定义的局部变量==>undefined, 添加为执行上下文的属性
        * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
        * this==>赋值(调用函数的对象)
      * 开始执行函数体代码

    - 1. 代码分类(位置)

      - 全局代码
      - 函数(局部)代码

    - 2. 全局执行上下文

      - 在执行全局代码前将window确定为全局执行上下文
      - 对全局数据进行预处理

        - var定义的全局变量==>undefined, 添加为window的属性
        - function声明的全局函数==>赋值(fun), 添加为window的方法
        - this==>赋值(window)

      - 开始执行全局代码

    - 3. 函数执行上下文

      - 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)
      - 对局部数据进行预处理

        - 形参变量==>赋值(实参)==>添加为执行上下文的属性
        - arguments==>赋值(实参列表), 添加为执行上下文的属性
        - var定义的局部变量==>undefined, 添加为执行上下文的属性
        - function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
        - this==>赋值(调用函数的对象)

      - 开始执行函数体代码

  - 执行上下文栈

    - 理解

      1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
      2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
      3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
      4. 在当前函数执行完后,将栈顶的对象移除(出栈)
      5. 当所有的代码执行完后, 栈中只剩下window

      - 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
      - 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
      - 在函数执行上下文创建后, 将其添加到栈中(压栈)
      - 在当前函数执行完后,将栈顶的对象移除(出栈)
      - 当所有的代码执行完后, 栈中只剩下window

    - 流程分析

      var a = 10

       var bar = function (x) {

         var b = 5

         foo(x + b)              

       }

       var foo = function (y) {

         var c = 5

         console.log(a + c + y)

       }

       bar(10)                   

  - 面试题

    /*
      测试题1: 
      */
      function a() {}
      var a;
      console.log(typeof a)
      /*
      测试题2: 
       */
      if (!(b in window)) {
        var b = 1;
      }
      console.log(b)
      /*
      测试题3: 
       */
      var c = 1
      function c(c) {
        console.log(c)
        var c = 3
      }
      c(2)

    - 测试题1:  先执行变量提升, 再执行函数提升

      -  function a() {}
         var a
         console.log(typeof a)

         - 'function'

    - 测试题2

      - if (!(b in window)) {
        var b = 1
        }
        console.log(b)

        - undefined

    - 测试题3

      -  var c = 1
         function c(c) {
         console.log(c)
         var c = 3
         }
         c(2) 

         - 报错

- 作用域与作用域链

  - 作用域

    1. 理解

      * 就是一块"地盘", 一个代码段所在的区域
      * 它是静态的(相对于上下文对象), 在编写代码时就确定了

    2. 分类

      * 全局作用域
      * 函数作用域
      * 没有块作用域(ES6有了)

    3. 作用

      * 隔离变量，不同作用域下同名变量不会有冲突

    - 1. 理解

      - 就是一块"地盘", 一个代码段所在的区域
      - 它是静态的(相对于上下文对象), 在编写代码时就确定了

    - 2. 分类

      - 全局作用域
      - 函数作用域
      - 没有块作用域(大括号域，ES6有了)

    - 3. 作用

      - 隔离变量，不同作用域下同名变量不会有冲突

  - 作用域与执行上下文

    1. 区别1

      * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
      * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
      * 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建

    2. 区别2

      * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
      * 上下文环境是动态的, 调用函数时创建, 函数调用结束时上下文环境就会被释放

    3. 联系

      * 上下文环境(对象)是从属于所在的作用域
      * 全局上下文环境==>全局作用域
      * 函数上下文环境==>对应的函数使用域

    - 区别1

      - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
      - 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
      - 函数执行上下文是在调用函数时, 函数体代码执行之前创建

    - 区别2

      - 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
      - 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放

    - 联系

      - 执行上下文(对象)是从属于所在的作用域
      - 全局上下文环境==>全局作用域
      - 函数上下文环境==>对应的函数使用域

  - 作用域链

    1. 理解

      * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
      * 查找变量时就是沿着作用域链来查找的

    2. 查找一个变量的查找规则

      * 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
      * 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
      * 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常

    - 理解

      - 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
      - 查找变量时就是沿着作用域链来查找的

    - 查找一个变量的查找规则

      - 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
      - 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
      - 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常

  - 面试题

    - 面试题1

      var x = 10;
        function fn() {
          console.log(x);
        }
        function show(f) {
          var x = 20;
          f();
        }
        show(fn);

      - 10

    - 面试题2

      var fn = function () {
          console.log(fn)
        }
        fn()
        var obj = {
          fn2: function () {
            console.log(fn2)
          }
        }
        obj.fn2()

      - 子主题 1

- 闭包

  - 引子实例

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script type="text/javascript">
              /*
    需求: 点击某个按钮, 提示"点击的是第n个按钮"
             */
        </script>
    </head>
    <body>
        <button>测试1</button>
        <button>测试2</button>
        <button>测试3</button>
    </body>
    </html>

  - 理解闭包

    1. 如何产生闭包?

      * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包

    2. 闭包到底是什么?

      * 使用chrome调试查看
      * 理解一: 闭包是嵌套的内部函数(绝大部分人)
      * 理解二: 包含被引用变量(函数)的对象(极少数人)
      * 注意: 闭包存在于嵌套的内部函数中

    3. 产生闭包的条件?

      * 函数嵌套
      * 内部函数引用了外部函数的数据(变量/函数)

    - 如何产生闭包?

      - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(或函数)时, 就产生了闭包

    - 闭包到底是什么?

      - 理解一: 闭包是嵌套的内部函数(绝大部分人)
      - 理解二: 包含被引用变量(函数)的对象(极少数人)
      - 使用chrome调试查看
      - 注意: 闭包存在于嵌套的内部函数中

    - 产生闭包的条件?

      - 函数嵌套
      - 内部函数引用了外部函数的数据(变量/函数)

        - 内部函数不需要调用，只需要执行函数定义

  - 常见的闭包

    1. 将函数作为另一个函数的返回值
    2. 将函数作为实参传递给另一个函数调用

    - 1. 将函数作为另一个函数的返回值
    - 2. 将函数作为实参传递给另一个函数调用

  - 闭包的作用

    1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
    2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

    问题:

        1. 函数执行完后, 函数内部声明的局部变量是否还存在?
        2. 在函数外部能直接访问函数内部的局部变量吗?

    - 1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)

    - 2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

    - 问题

      - 1. 函数执行完后, 函数内部声明的局部变量是否还存在?

        - 一般是不存在, 存在于闭包中的变量才可能存在

      - 2. 在函数外部能直接访问函数内部的局部变量吗?

        - 不能, 但我们可以通过闭包让外部操作它

  - 闭包的生命周期

    1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
    2. 死亡: 在嵌套的内部函数成为垃圾对象时

    <script type="text/javascript">
      function fun1() {
        //问题2: 此时闭包产生了吗? 
        var a = 3;
        function fun2() {
          a++;
          console.log(a);
        }
        return fun2;
      }
      //问题1: 此时闭包产生了吗?   
      var f = fun1();
      //问题3: 此时闭包释放了吗?  
      f();
      f();
      //问题4: 此时闭包释放回收了吗?   
      //问题5: 如何让闭包释放回收呢?
    	f = null
    </script>


    - 产生

      -  在嵌套内部函数定义执行完时就产生了(不是在调用)

    - 死亡

      - 在嵌套的内部函数成为垃圾对象时

  - 闭包的应用: 自定义JS模块

    闭包的应用 : 定义JS模块

      * 具有特定功能的js文件
      * 将所有的数据和功能都封装在一个函数内部(私有的)
      * 只向外暴露一个包信n个方法的对象或函数
      * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

    - module
    - 特点

      - 具有特定功能的js文件
      - 将所有的数据和功能都封装在一个函数内部(私有的)
      - 只向外暴露一个包信n个方法的对象或函数

        - return  {}
        - window.myModule2 = { }

      - 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

  - 闭包的缺点及解决

    1. 缺点

      * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
      * 容易造成内存泄露

    2. 解决

      * 能不用闭包就不用
      * 及时释放

    - 缺点

      - 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
      - 容易造成内存泄露

    - 解决

      - 能不用闭包就不用
      - 及时释放

  - 面试题

    - 面试题一

      //代码片段一
      var name = "The Window";
      var object = {
          name : "My Object",
          getNameFunc : function(){
              return function(){
                  return this.name;
              };
          }
      };
      alert(object.getNameFunc()());  //?


      //代码片段二
      var name2 = "The Window";
      var object2 = {
          name2 : "My Object",
          getNameFunc : function(){
              var that = this;
              return function(){
                  return that.name2;
              };
          }
      };
      alert(object2.getNameFunc()()); //?

    - 面试题二

      function fun(n,o) {
              console.log(o)
              return {
                  fun:function(m){
                      return fun(m,n);
                  }
              };
          }
          var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
          var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
          var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?

  - 内存溢出与内存泄漏

    - 内存溢出

      - 一种程序运行出现的错误
      - 当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误

    - 内存泄露

      - 占用的内存没有及时释放
      - 内存泄露积累多了就容易导致内存溢出
      - 常见的内存泄露

        - 意外的全局变量（未使用var定义变量）
        - 没有及时清理的计时器或回调函数（setInterval）
        - 闭包

### 面向对象高级

- 对象创建模式

  - Object构造函数模式

    方式1: Object构造函数模式

      * 套路: 先创建空Object对象, 再动态添加属性/方法
      * 适用场景: 起始时不确定对象内部数据
      * 问题: 语句太多

    - 套路

      - 先创建空Object对象, 再动态添加属性/方法

        - p = new Object()

    - 适用场景

      - 起始时不确定对象内部数据

    - 问题

      - 语句太多

  - 对象字面量模式

    方式2: 对象字面量模式

      * 套路: 使用{}创建对象, 同时指定属性/方法
      * 适用场景: 起始时对象内部数据是确定的
      * 问题: 如果创建多个对象, 有重复代码

    - 套路

      - 使用{}创建对象, 同时指定属性/方法

    - 适用场景

      - 起始时对象内部数据是确定的

    - 问题

      - 如果创建多个对象, 有重复代码

  - 工厂模式

    方式3: 工厂模式

      * 套路: 通过工厂函数动态创建对象并返回

      * 适用场景: 需要创建多个对象

      * 问题: 对象没有一个具体的类型, 都是Object类型

    - 套路

      - 通过工厂函数（返回一个对象的函数）动态创建对象并返回

    - 适用场景

      - 需要创建多个对象

    - 问题

      - 对象没有一个具体的类型, 都是Object类型

  - 自定义构造函数模式

    方式4: 自定义构造函数模式

      * 套路: 自定义构造函数, 通过new创建对象

      * 适用场景: 需要创建多个类型确定的对象

      * 问题: 每个对象都有相同的数据, 浪费内存

    - 套路

      - 自定义构造函数, 通过new创建对象

    - 适用场景

      - 需要创建多个类型确定的对象

    - 问题

      - 每个对象都有相同的数据, 浪费内存

  - 构造函数+原型的组合模式

    方式5: 构造函数+原型的组合模式

      * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上
      * 适用场景: 需要创建多个类型确定的对象

    - 套路

      - 自定义构造函数, 属性在函数中初始化, 方法添加到原型上

    - 适用场景

      - 需要创建多个类型确定的对象

- 继承模式

  - 原型链继承

    方式1: 原型链继承

        1. 套路
               1. 定义父类型构造函数
                      2. 给父类型的原型添加方法
                             3. 定义子类型的构造函数
                                    4. 创建父类型的对象赋值给子类型的原型
                                           5. 将子类型原型的构造属性设置为子类型
                                                  6. 给子类型原型添加方法
                                                         7. 创建子类型的对象: 可以调用父类型的方法
        2. 关键
               1. 子类型的原型为父类型的一个实例对象

    - 套路

      - 1. 定义父类型构造函数
      - 2. 给父类型的原型添加方法
      - 3. 定义子类型的构造函数
      - 4. 创建父类型的对象赋值给子类型的原型
      - 5. 将子类型原型的构造属性设置为子类型
      - 6. 给子类型原型添加方法
      - 7. 创建子类型的对象: 可以调用父类型的方法

    - 关键

      - 子类型的原型为父类型的一个实例对象

  - 借用构造函数继承（假继承）

    方式2: 借用构造函数继承(假的)

    1. 套路:
      2. 定义父类型构造函数
      3. 定义子类型构造函数
      4. 在子类型构造函数中调用父类型构造
    5. 关键:
      6. 在子类型构造函数中通用super()调用父类型构造函数

    - 套路

      - 1. 定义父类型构造函数
      - 2. 定义子类型构造函数
      - 3. 在子类型构造函数中调用父类型构造

    - 关键

      - 1. 在子类型构造函数中通用  call()  调用父类型构造函数

        - Person.call(this, name, age)  // 相当于: this.Person(name, age)

  - 组合继承

    方式3: 原型链+借用构造函数的组合继承

    1. 利用原型链实现对父类型对象的方法继承
    2. 利用super()借用父类型构建函数初始化相同属性

    - 原型链+借用构造函数的组合继承

      - 1. 利用原型链实现对父类型对象的方法继承
      - 2. 利用super()借用父类型构建函数初始化相同属性

### 线程机制与事件机制

- 进程与线程

  - 进程(process)

    - 程序的一次执行, 它占有一片独有的内存空间
    - 可以通过windows任务管理器查看进程

  - 线程(thread)

    - 是进程内的一个独立执行单元
    - 是程序执行的一个完整流程
    - 是CPU的最小的调度单元

  - 相关知识

    - 应用程序必须运行在某个进程的某个线程上
    - 一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建
    - 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
    - 一个进程内的数据可以供其中的多个线程直接共享
    - 多个进程之间的数据是不能直接共享的
    - 线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用

  - 相关问题

    - 何为多进程与多线程?

      - 多进程运行: 一应用程序可以同时启动多个实例运行
      - 多线程: 在一个进程内, 同时有多个线程运行

    - 比较单线程与多线程?

      - 多线程

        - 优点

          - 能有效提升CPU的利用率

        - 缺点

          - 创建多线程开销
          - 线程间切换开销
          - 死锁与状态同步问题

      - 单线程

        - 优点

          - 顺序编程简单易懂

        - 缺点

          - 效率低

    - JS是单线程还是多线程?

      - js是单线程运行的
      - 但使用H5中的 Web Workers可以多线程运行
      - 只能是主线程更新界面

    - 浏览器运行是单线程还是多线程?

      - 都是多线程运行的

    - 浏览器运行是单进程还是多进程?

      - 有的是单进程

        - firefox
        - 老版IE

      - 有的是多进程

        - chrome
        - 新版IE

      - 如何查看浏览器是否是多进程运行的呢?

        - 任务管理器-->进程

- 浏览器内核

  - 支撑浏览器运行的最核心的程序
  - 不同的浏览器可能不一样

    - Chrome, Safari 

      - webkit

    - firefox

      - Gecko

    - IE	

      - Trident

    - 360,搜狗等国内浏览器

      - Trident + webkit

  - 内核由很多模块组成

    - js引擎模块 

      - 负责js程序的编译与运行

    - html,css文档解析模块 

      - 负责页面文本的解析

    - DOM/CSS模块 

      - 负责dom/css在内存中的相关处理 

    - 布局和渲染模块

      -  负责页面的布局和效果的绘制(内存中的对象)

    - ......
    - 定时器模块 

      - 负责定时器的管理

    - DOM事件响应模块 

      - 负责事件的管理

    - 网络请求模块

      - 负责ajax请求

- 定时器引发的思考

  1. 定时器真是定时执行的吗?

    * 定时器并不能保证真正定时执行
    * 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)

  2. 定时器回调函数是在分线程执行的吗?

    * 在主线程执行的, js是单线程的

  3. 定时器是如何实现的?

    * 事件循环模型(后面讲)

  - 1. 定时器真是定时执行的吗?

    - 定时器并不能保证真正定时执行
    - 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)

  - 2. 定时器回调函数是在哪个线程执行的?

    - 在主线程执行的, js是单线程的

  - 3. 定时器是如何实现的?

    - 事件循环模型(后面讲)

- JS是单线程执行的

  1. 如何证明js执行是单线程的?

    * setTimeout()的回调函数是在主线程执行的

    * 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

  2. 为什么js要用单线程模式, 而不用多线程模式?

    * JavaScript的单线程，与它的用途有关。

    * 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。

    * 这决定了它只能是单线程，否则会带来很复杂的同步问题

  

  3. 代码的分类:

    * 初始化代码

    * 回调代码

  4. js引擎执行代码的基本流程

    * 先执行初始化代码: 包含一些特别的代码

      * 设置定时器

      * 绑定监听

      * 发送ajax请求

    * 后面在某个时刻才会执行回调代码

  - 1. 如何证明js执行是单线程的?

    - setTimeout()的回调函数是在主线程执行的
    - 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

      - setTimeout()的回调函数是在主线程执行的

    - alert

      - 暂停当前主线程的执行, 同时暂停计时, 点击确定后, 恢复程序执行和计时

  - 2. 为什么js要用单线程模式, 而不用多线程模式?

    - JavaScript的单线程，与它的用途有关。
    - 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
    - 这决定了它只能是单线程，否则会带来很复杂的同步问题

  - 3. 代码的分类

    - 初始化代码

      - 包含绑定dom事件监听，设置定时器，发送Ajax请求的代码

    - 回调代码

      - 处理回调逻辑

  - 4. js引擎执行代码的基本流程

    - 先执行初始化代码: 包含一些特别的代码   回调函数(异步执行)

      - 设置定时器
      - 绑定事件监听
      - 发送ajax请求

    - 后面在某个时刻才会执行回调代码

- 浏览器的事件循环(轮询)模型

  1. 所有代码分类

    * 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
    * 回调执行代码: 处理回调逻辑

  2. js引擎执行代码的基本流程:

    * 初始化代码===>回调代码

  3. 模型的2个重要组成部分:

    * 事件管理模块
    * 回调队列

  4. 模型的运转流程

    * 执行初始化代码, 将事件回调函数交给对应模块管理
    * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
    * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

  - 模型原理图

  - 相关重要概念

    1. 执行栈
       execution stack
       所有的代码都是在此空间中执行的
     2. 浏览器内核
        browser core
        js引擎模块(在主线程处理)
        其它模块(在主/分线程处理)
     3. 任务队列(callback queue)
        task queue
     4. 消息队列(callback queue)
        message queue
     5. 事件队列(callback queue)
        event queue
     6. 事件轮询
        event loop
        从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)
     7. 事件驱动模型
        event-driven interaction model
     8. 请求响应模型
        request-response model

    - 1. 执行栈

      - execution stack
      - 所有的代码都是在此空间中执行的

    - 2. 浏览器内核

      - browser core
      - js引擎模块  (在主线程处理)
      - 其它模块  (在主/分线程处理)

    - 3. 任务队列

      - task queue

    - 4. 消息队列

      - message queue

    - 5. 事件队列

      - event queue

    - 6. 事件轮询

      - event loop
      - 从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)

    - 7. 事件驱动模型

      - event-driven interaction model

    - 8. 请求响应模型

      - request-response model

  - 模型的2个重要组成部分

    - 事件(定时器/DOM事件/Ajax)管理模块
    - 回调队列

  - 执行流程

    - 执行初始化代码, 将事件回调函数交给对应模块管理
    - 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
    - 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

- H5 Web Workers(多线程)

  - 介绍

    - Web Workers 是 HTML5 提供的一个javascript多线程解决方案
    - 我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面
    - 但是子线程完全受主线程控制，且不得操作DOM。
      所以，这个新标准并没有改变JavaScript单线程的本质

  - 使用

    - 创建在分线程执行的js文件

      var onmessage =function (event){ //不能用函数声明
          console.log('onMessage()22');
          var upper = event.data.toUpperCase();//通过event.data获得发送来的数据
          postMessage( upper );//将获取到的数据发送会主线程
      }

    - 在主线程中的js中发消息并设置回调

      //创建一个Worker对象并向它传递将在新线程中执行的脚本的URL
      var worker = new Worker("worker.js");  
      //接收worker传过来的数据函数
      worker.onmessage = function (event) {     
          console.log(event.data);             
      };
      //向worker发送数据
      worker.postMessage("hello world");

  - 图解

  - 应用练习

    编程实现斐波那契数列（Fibonacci sequence）的计算

    F（0）=0，F（1）=1，..... F（n）=F(n-1)+F(n-2)

    - 直接在主线程

      var fibonacci =function(n) {
          return n <2 ? n : fibonacci(n -1) + fibonacci(n -2);
      };
      console.log(fibonacci(48));

    - 使用Worker在分线程

      - 主线程

        var worker = new Worker('worker2.js');
        worker.addEventListener('message', function (event) {
            var timer2 = new Date().getTime();
            console.log('结果：' + event.data, '时间:' + timer2, '用时：' + ( timer2 - timer ));
        }, false);

        var timer = new Date().getTime();
        console.log('开始计算: ', '时间:' + timer);
        setTimeout(function () {
            console.log('定时器函数在计算数列时执行了', '时间:' + new Date().getTime());
        }, 1000);

        worker.postMessage(40);
        console.log('我在计算数列的时候执行了', '时间:' + new Date().getTime());

      - 分线程

        var fibonacci =function(n) {

            return n <2 ? n : fibonacci(n -1) + fibonacci(n -2);

        };

        

        var onmessage = function(event) {

            var n = parseInt(event.data, 10);
            
            postMessage(fibonacci(n));

        };

  - 不足

    1. 慢
    2. 不能跨域加载JS
    3. worker内代码不能访问DOM(更新UI)
    4. 不是每个浏览器都支持这个新特性

    - 慢（区别冻结主界面）
    - worker内代码不能操作DOM(更新UI)

      - 全局对象不是window

    - 不能跨域加载JS
    - 不是每个浏览器都支持这个新特性

